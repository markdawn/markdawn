#include "StdAfx.h"
#include "TravelTime.h"
#include <math.h>


TravelTime::TravelTime(void)
{
	Nlength=5120;
	SaLen=200;
	SaCut=800;
	SabLen=2200;
	SampF=20224;
}


TravelTime::~TravelTime(void)
{
}

void TravelTime::CalcTime()
{
	int i,imax,k;
	float tempX[N_DATALENTH]={0},tempY[N_DATALENTH]={0},M[2]={0},temp[N_DATALENTH]={0};
	float mymax=0;
	bool VFlag,WFlag,MFlag;
	for(i=0;i<Nlength;i++)
	{
		temp[i]=Data[0][i];
	}
	MFlag=TRUE;
	k=0;
	imax=0;
	for(i=0;i<200;i++)        //200 发声端接收稳定点 1000开始发声前点
	{
		temp[i]=Data[0][200];
	}
	for(i=200;i<1000;i++)
	{
		if((fabs(temp[i]-temp[1])>=lVal)&&MFlag)
		{
			k=int((i-840)/20.0);
			if(fabs(1.0*k)>=2)
			{
				SaCut+=k*20;
				SabLen+=k*20;
			}
			if(SaCut>950)
			{
				SaCut=950;
				SabLen=2000;
			}
			MFlag=FALSE;
		}
	}
	for(i=0;i<SaCut;i++)
	{
		tempX[i]=temp[i];
	}
	VFlag=TRUE;
	for(i=SaCut;i<(SaLen+SaCut);i++)
	{
		if((fabs(temp[i])<0.2)&&VFlag)
		{
			tempX[i]=temp[1];
			M[0]=i;
		}
		else
		{
			tempX[i]=temp[i];
			VFlag=FALSE;
		}
	}
	for(i=(SaLen+SaCut);i<Nlength;i++)
	{
		tempX[i]=temp[1];
	}
	//dataY
	for(i=0;i<Nlength;i++)
	{
		temp[i]=Data[1][i];
	}
	for(i=0;i<200;i++)        //process DataY same as DataX
	{
		temp[i]=Data[1][200];
	}
	WFlag=TRUE;
	for(i=0;i<Nlength;i++)
	{
		if((fabs(temp[i])<0.2)&&WFlag)
		{
			tempY[i]=temp[1];
			M[1]=i;
		}
		else
		{
			tempY[i]=temp[i];
			WFlag=FALSE;
		}
	}
	float size_n;
	size_n=(M[1]+SaLen)*1.0;
	size_y=int(pow(2.0,int(log(1.0*size_n)/log(2.0))+1));
	for(i=0;i<size_n;i++)
	{
		xr[i]=tempX[i];
		yr[i]=tempY[i];
		xi[i]=0;
		yi[i]=0;
	}
	for(i=size_n;i<size_y;i++)
	{
		xr[i]=tempX[0];
		yr[i]=tempY[i];
		xi[i]=0;
		yi[i]=0;
	}
	/*
//debug
	double tar[128]={0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,9.51056516e-01,5.87785252e-01,-5.87785252e-01,
		-9.51056516e-01,-2.44929360e-16,9.51056516e-01,5.87785252e-01,
		-5.87785252e-01,-9.51056516e-01,-4.89858720e-16,9.51056516e-01,
		5.87785252e-01,-5.87785252e-01,-9.51056516e-01,-7.34788079e-16,
		9.51056516e-01,5.87785252e-01,-5.87785252e-01,-9.51056516e-01,
		-9.79717439e-16,9.51056516e-01,5.87785252e-01,-5.87785252e-01,
		-9.51056516e-01,-1.22464680e-15,9.51056516e-01,5.87785252e-01,
		-5.87785252e-01,-9.51056516e-01,-1.46957616e-15,9.51056516e-01,
		5.87785252e-01,-5.87785252e-01,-9.51056516e-01,-1.71450552e-15,
		9.51056516e-01,5.87785252e-01,-5.87785252e-01,-9.51056516e-01,
		-1.95943488e-15,9.51056516e-01,5.87785252e-01,-5.87785252e-01,
		-9.51056516e-01,-2.20436424e-15,9.51056516e-01,5.87785252e-01,
		-5.87785252e-01,-9.51056516e-01,-2.44929360e-15,9.51056516e-01,
		5.87785252e-01,-5.87785252e-01,-9.51056516e-01,4.41120440e-15,
		9.51056516e-01,5.87785252e-01,-5.87785252e-01,-9.51056516e-01,
		-2.93915232e-15,9.51056516e-01,5.87785252e-01,-5.87785252e-01};
	double tbr[128]={0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,-5.87785252e-01,5.87785252e-01,
		9.51056516e-01,-2.93915232e-15,-9.51056516e-01,-5.87785252e-01,
		5.87785252e-01,9.51056516e-01,4.41120440e-15,-9.51056516e-01,
		-5.87785252e-01,5.87785252e-01,9.51056516e-01,-2.44929360e-15,
		-9.51056516e-01,-5.87785252e-01,5.87785252e-01,9.51056516e-01,
		-2.20436424e-15,-9.51056516e-01,-5.87785252e-01,5.87785252e-01,
		9.51056516e-01,-1.95943488e-15,-9.51056516e-01,-5.87785252e-01,
		5.87785252e-01,9.51056516e-01,-1.71450552e-15,-9.51056516e-01,
		-5.87785252e-01,5.87785252e-01,9.51056516e-01,-1.46957616e-15,
		-9.51056516e-01,-5.87785252e-01,5.87785252e-01,9.51056516e-01,
		-1.22464680e-15,-9.51056516e-01,-5.87785252e-01,5.87785252e-01,
		9.51056516e-01,-9.79717439e-16,-9.51056516e-01,-5.87785252e-01,
		5.87785252e-01,9.51056516e-01,-7.34788079e-16,-9.51056516e-01,
		-5.87785252e-01,5.87785252e-01,9.51056516e-01,-4.89858720e-16,
		-9.51056516e-01,-5.87785252e-01,5.87785252e-01,9.51056516e-01,
		-2.44929360e-16,-9.51056516e-01,-5.87785252e-01,5.87785252e-01,
		9.51056516e-01,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00,
		0.00000000e+00,0.00000000e+00,0.00000000e+00,0.00000000e+00};
	size_y=128;
	double tzr[128]={0},tzi[128]={0},tai[128]={0},tbi[128]={0};
//	fft_conv(tar,tai,tbr,tbi,tzr,tzi,size_y);
//  debug_end */
	fft_conv(xr,xi,yr,yi,zr,zi,size_y);
	for(i=0;i<size_y;i++)
	{
		if(mymax<zr[i])
		{
			imax=i;
			mymax=zr[i];
		}
	}
	TimeVal=imax/SampF;
}

void TravelTime::Init(unsigned int uSL,unsigned int uSC,unsigned int uSb,float SF,float lV)
{
	SaLen=uSL;
	SaCut=uSC;
	SabLen=uSb;
	SampF=SF;
	lVal=lV;
}

//void TravelTime::readdata(float mydata[2][N],int n)
void TravelTime::readdata(float** mydata,int n)
{
	if (mydata==NULL)
	{
		return;
	}
	int i;
	Nlength=n;
	for(i=0;i<n;i++)
	{
		Data[0][i]=mydata[0][i];
		Data[1][i]=mydata[1][i];
	}
}

float TravelTime::GetTime()
{
	return TimeVal;
}